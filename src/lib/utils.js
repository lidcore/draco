// Generated by BUCKLESCRIPT VERSION 4.0.17, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Printf = require("bs-platform/lib/js/printf.js");
var Printexc = require("bs-platform/lib/js/printexc.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var BsAsyncMonad = require("bs-async-monad/src/bsAsyncMonad.js");
var Buffer$LidcoreBsNode = require("@lidcore/bs-node/src/buffer.js");
var Process$LidcoreBsNode = require("@lidcore/bs-node/src/process.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Child_process$LidcoreBsNode = require("@lidcore/bs-node/src/child_process.js");

function get_some(param) {
  if (param !== undefined) {
    return Caml_option.valFromOption(param);
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "utils.ml",
            6,
            12
          ]
        ];
  }
}

function partition(size, a) {
  var len = a.length;
  var ret = /* array */[];
  var pos = 0;
  while(pos < len) {
    ret.push(a.slice(pos, pos + size | 0));
    pos = pos + size | 0;
  };
  return ret;
}

function $$escape(s) {
  return Curry._1(Printf.sprintf(/* Format */[
                  /* Caml_string */Block.__(3, [
                      /* No_padding */0,
                      /* End_of_format */0
                    ]),
                  "%S"
                ]), s);
}

function $$delete (key,obj){delete obj[key];};

function replace_process(cmd, cb) {
  var stdio_000 = /* stdin : `Inherit */[
    -72987685,
    Process$LidcoreBsNode.stdin
  ];
  var stdio_001 = /* stdout : `Inherit */[
    -72987685,
    Process$LidcoreBsNode.stdout
  ];
  var stdio_002 = /* stderr : `Inherit */[
    -72987685,
    Process$LidcoreBsNode.stderr
  ];
  var stdio = /* record */[
    stdio_000,
    stdio_001,
    stdio_002
  ];
  var child = Child_process$LidcoreBsNode.spawn(undefined, undefined, stdio, true, cmd);
  var finished = /* record */[/* contents */false];
  Child_process$LidcoreBsNode.on(child, /* `Error */[
        106380200,
        (function (exn) {
            finished[0] = true;
            return BsAsyncMonad.Callback[/* fail */1](exn, cb);
          })
      ]);
  return Child_process$LidcoreBsNode.on(child, /* `Exit */[
              771171134,
              (function (e) {
                  if (finished[0]) {
                    return 0;
                  } else {
                    finished[0] = true;
                    if (e[0] >= 748543309) {
                      if (e[1] !== 0) {
                        return BsAsyncMonad.Callback[/* fail */1](e, cb);
                      } else {
                        return BsAsyncMonad.Callback[/* return */0](/* () */0, cb);
                      }
                    } else if (e[1] === "SIGTERM") {
                      return BsAsyncMonad.Callback[/* return */0](/* () */0, cb);
                    } else {
                      return BsAsyncMonad.Callback[/* fail */1](e, cb);
                    }
                  }
                })
            ]);
}

Printexc.register_printer((function (param) {
        if (param[0] === Js_exn.$$Error) {
          return param[1].toString();
        }
        
      }));

function printexc(exn) {
  try {
    return exn.toString();
  }
  catch (exn$1){
    if (Array.isArray(exn)) {
      return Printexc.to_string(exn);
    } else {
      return "" + (String(exn) + "");
    }
  }
}

var parse = (function (x) {
    return JSON.parse(x);
  });

function parse_buf(buf) {
  return Curry._1(parse, Buffer$LidcoreBsNode.toString(undefined, undefined, undefined, buf));
}

function stringify(obj) {
  var match = JSON.stringify(obj);
  if (match !== undefined) {
    return match;
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "utils.ml",
            79,
            16
          ]
        ];
  }
}

var Json = /* module */[
  /* parse */parse,
  /* parse_buf */parse_buf,
  /* stringify */stringify
];

exports.get_some = get_some;
exports.partition = partition;
exports.$$escape = $$escape;
exports.replace_process = replace_process;
exports.$$delete = $$delete;
exports.printexc = printexc;
exports.Json = Json;
/*  Not a pure module */
