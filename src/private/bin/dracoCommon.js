// Generated by BUCKLESCRIPT VERSION 4.0.6, PLEASE EDIT WITH CARE
'use strict';

var Arg = require("bs-platform/lib/js/arg.js");
var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var BsAsyncMonad = require("bs-async-monad/src/bsAsyncMonad.js");
var Env$LidcoreDraco = require("../../lib/env.js");
var Fs$LidcoreBsNode = require("@lidcore/bs-node/src/fs.js");
var Yaml$LidcoreDraco = require("../../bindings/yaml.js");
var Path$LidcoreBsNode = require("@lidcore/bs-node/src/path.js");
var Utils$LidcoreDraco = require("../../lib/utils.js");
var Buffer$LidcoreBsNode = require("@lidcore/bs-node/src/buffer.js");
var Process$LidcoreBsNode = require("@lidcore/bs-node/src/process.js");
var Deepmerge$LidcoreDraco = require("../../bindings/deepmerge.js");

var stage = /* record */[/* contents */Env$LidcoreDraco.get("staging", "STAGE")];

var argc = Process$LidcoreBsNode.argv.length - 1 | 0;

var argv = $$Array.sub(Process$LidcoreBsNode.argv, 1, argc);

var args_000 = /* tuple */[
  "-stage",
  /* Set_string */Block.__(5, [stage]),
  "Set stage"
];

var args = /* :: */[
  args_000,
  /* [] */0
];

try {
  Arg.parse_argv(undefined, Process$LidcoreBsNode.argv, args, (function () {
          return /* () */0;
        }), "");
}
catch (exn){
  
}

var usageMsg = /* record */[/* contents */"Usage: draco [mode] [options] [-stage <stage>]"];

function usage($staropt$star, opts) {
  var staged = $staropt$star !== undefined ? $staropt$star : true;
  var stage = staged ? "[-stage <stage>]" : "";
  usageMsg[0] = "Usage: draco " + (String(opts) + (" " + (String(stage) + "")));
  return /* () */0;
}

var baseDir = Path$LidcoreBsNode.normalize("" + (String(__dirname) + "/../../../../.."));

var stage$1 = stage[0];

var configPath = "" + (String(baseDir) + ("/config/" + (String(stage$1) + "/draco.yml")));

function getPath(file) {
  return Fs$LidcoreBsNode.realpathSync("" + (String(__dirname) + ("/../../" + (String(file) + ""))));
}

var defaultConfigPath = getPath("config.yml");

function configSubs() {
  return /* :: */[
          /* tuple */[
            (/@module_path@/g),
            getPath("")
          ],
          /* :: */[
            /* tuple */[
              (/@stage@/g),
              stage[0]
            ],
            /* [] */0
          ]
        ];
}

function getConfig(path) {
  var subs = configSubs(/* () */0);
  var content = Buffer$LidcoreBsNode.toString(undefined, undefined, undefined, Fs$LidcoreBsNode.readFileSync(path));
  return Yaml$LidcoreDraco.parse(List.fold_left((function (content, param) {
                    return content.replace(param[0], param[1]);
                  }), content, subs));
}

function config() {
  return Deepmerge$LidcoreDraco.merge(getConfig(defaultConfigPath), getConfig(configPath));
}

var error = function (s){console.error(s);};

function die(msg, _) {
  if (msg !== undefined) {
    error(msg);
  }
  error(usageMsg[0]);
  return Process$LidcoreBsNode.exit(1);
}

if (!Fs$LidcoreBsNode.existsSync(configPath)) {
  die("Couldn\'t find config file " + (String(configPath) + ""), /* () */0);
}

var rebuild = BsAsyncMonad.Callback[/* >> */3]((function (param) {
        return Utils$LidcoreDraco.replace_process("npm run clean", param);
      }), (function () {
        return (function (param) {
            return Utils$LidcoreDraco.replace_process("npm run build", param);
          });
      }));

exports.argc = argc;
exports.argv = argv;
exports.baseDir = baseDir;
exports.usage = usage;
exports.usageMsg = usageMsg;
exports.configPath = configPath;
exports.config = config;
exports.die = die;
exports.getPath = getPath;
exports.rebuild = rebuild;
/* stage Not a pure module */
